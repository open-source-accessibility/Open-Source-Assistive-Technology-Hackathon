<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="GitHub Learning Room - Open Source Assistive Technology Hackathon">
  <title>Appendix C: Git Authentication - GitHub Learning Room</title>
  <link rel="stylesheet" href="./styles/github-markdown.css">
  <link rel="stylesheet" href="./styles/highlight.css">
  <link rel="stylesheet" href="./styles/custom.css">
  <style>
    .markdown-body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }
    @media (max-width: 767px) {
      .markdown-body {
        padding: 15px;
      }
    }
  </style>
</head>
<body>
  <nav aria-label="Breadcrumb" class="breadcrumb">
    <a href="./index.html">Home</a>
  </nav>
  <main class="markdown-body">
    <h1>Appendix C: Git Authentication</h1>
<h2>SSH Keys &amp; Personal Access Tokens</h2>
<blockquote>
<p><strong>Audience:</strong> This appendix is for contributors who need to configure Git authentication for push access. If you&#39;re working entirely through the GitHub web interface or GitHub Desktop, you can skip this. If you&#39;re using VS Code with Git command line, this becomes relevant when you want to push commits to your fork.</p>
</blockquote>
<hr>
<h2>When You Need Authentication</h2>
<p>GitHub requires authentication when you:</p>
<ul>
<li><strong>Push</strong> commits to a repository</li>
<li><strong>Clone</strong> a private repository</li>
<li><strong>Access</strong> organization repositories with specific permissions</li>
</ul>
<p>You do <strong>not</strong> need authentication to:</p>
<ul>
<li>Clone public repositories</li>
<li>View public repositories on GitHub.com</li>
<li>Read issues and pull requests</li>
</ul>
<hr>
<h2>Two Authentication Methods</h2>
<h3>Personal Access Token (PAT)</h3>
<p>A Personal Access Token is a password-like string you generate on GitHub and use instead of your account password when Git asks for credentials.</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Works on all operating systems</li>
<li>Easy to set up for screen reader users (no command line required)</li>
<li>Can be scoped to specific permissions</li>
<li>Easy to revoke if compromised</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>You have to store it securely</li>
<li>Expires after a set time (you must regenerate)</li>
</ul>
<h3>SSH Keys</h3>
<p>SSH uses public-key cryptography. You generate a key pair on your computer (public + private), upload the public key to GitHub, and Git uses the private key to prove your identity.</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Once set up, works automatically (no password prompts)</li>
<li>More secure than tokens</li>
<li>Never expires</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires command-line setup (less accessible for some screen reader users)</li>
<li>Slightly more complex initial configuration</li>
</ul>
<hr>
<h2>Creating a Personal Access Token (Recommended for This Workshop)</h2>
<p><strong>Why this method:</strong> It&#39;s screen reader accessible through the GitHub web interface, and you can complete it without command-line Git configuration.</p>
<h3>Step 1: Generate the Token</h3>
<ol>
<li>Navigate to <a href="https://github.com/settings/tokens">github.com/settings/tokens</a></li>
<li>Select <strong>&quot;Tokens (classic)&quot;</strong> from the left sidebar</li>
<li>Activate <strong>&quot;Generate new token&quot;</strong> → Select <strong>&quot;Generate new token (classic)&quot;</strong></li>
<li>Give it a descriptive name in the <strong>Note</strong> field: &quot;Workshop Laptop Token&quot;</li>
<li>Set expiration: <strong>30 days</strong> or <strong>60 days</strong> (recommended for temporary workshop use)</li>
<li>Select scopes:<ul>
<li>✅ <strong><code>repo</code></strong> — Full control of private repositories (includes public repo access)</li>
<li>✅ <strong><code>workflow</code></strong> — Update GitHub Actions workflows (if you&#39;ll work with Actions)</li>
</ul>
</li>
<li>Scroll down and activate <strong>&quot;Generate token&quot;</strong></li>
<li><strong>CRITICAL:</strong> Copy the token immediately — you cannot see it again</li>
</ol>
<p><strong>Screen reader note:</strong> The token appears as a long string in a text field. Select all (<code>Ctrl+A</code>), copy (<code>Ctrl+C</code>), and paste it into a secure note or password manager.</p>
<h3>Step 2: Store It Securely</h3>
<p><strong>Options:</strong></p>
<ul>
<li><strong>Password manager</strong> (1Password, Bitwarden, LastPass) — best option</li>
<li><strong>Encrypted note</strong> in your operating system&#39;s secure notes</li>
<li><strong>Plain text file</strong> in an encrypted folder (temporary only)</li>
</ul>
<p><strong>Do not:</strong></p>
<ul>
<li>Paste it into a document you sync to cloud storage unencrypted</li>
<li>Email it to yourself</li>
<li>Save it in a public GitHub file</li>
</ul>
<h3>Step 3: Use It</h3>
<p>The next time Git asks for your password (when you push, pull from a private repo, or clone a private repo):</p>
<pre><code>Username: [your-github-username]
Password: [paste-your-PAT-here]
</code></pre>
<p><strong>Windows Git Credential Manager:</strong> Windows will remember this token automatically after your first use. You only paste it once.</p>
<p><strong>macOS Keychain:</strong> macOS will offer to save it to Keychain. Select &quot;Always Allow.&quot;</p>
<p><strong>Linux:</strong> You can configure Git to cache credentials:</p>
<pre><code class="language-bash">git config --global credential.helper cache
</code></pre>
<hr>
<h2>Setting Up SSH Keys (Alternative Method)</h2>
<p>If you prefer SSH and are comfortable with terminal commands:</p>
<h3>Step 1: Check If You Already Have a Key</h3>
<pre><code class="language-bash">ls -al ~/.ssh
</code></pre>
<p>Look for files named <code>id_rsa.pub</code>, <code>id_ed25519.pub</code>, or similar. If you see these, you already have a key.</p>
<h3>Step 2: Generate a New SSH Key</h3>
<pre><code class="language-bash">ssh-keygen -t ed25519 -C &quot;your-email@example.com&quot;
</code></pre>
<p>When prompted:</p>
<ul>
<li>Press <code>Enter</code> to accept the default file location</li>
<li>Enter a passphrase (optional but recommended)</li>
</ul>
<p><strong>Screen reader note:</strong> Git will print output showing where the key was saved. It generates two files: <code>id_ed25519</code> (private) and <code>id_ed25519.pub</code> (public).</p>
<h3>Step 3: Copy Your Public Key</h3>
<p><strong>Windows (PowerShell):</strong></p>
<pre><code class="language-powershell">Get-Content ~/.ssh/id_ed25519.pub | Set-Clipboard
</code></pre>
<p><strong>macOS:</strong></p>
<pre><code class="language-bash">pbcopy &lt; ~/.ssh/id_ed25519.pub
</code></pre>
<p><strong>Linux:</strong></p>
<pre><code class="language-bash">cat ~/.ssh/id_ed25519.pub
# Manually select and copy the output
</code></pre>
<h3>Step 4: Add to GitHub</h3>
<ol>
<li>Navigate to <a href="https://github.com/settings/keys">github.com/settings/keys</a></li>
<li>Select <strong>&quot;New SSH key&quot;</strong></li>
<li><strong>Title:</strong> &quot;Workshop Laptop SSH Key&quot;</li>
<li><strong>Key type:</strong> Authentication Key</li>
<li><strong>Key:</strong> Paste your public key (should start with <code>ssh-ed25519</code> or <code>ssh-rsa</code>)</li>
<li>Select <strong>&quot;Add SSH key&quot;</strong></li>
<li>Confirm with your password or 2FA code</li>
</ol>
<h3>Step 5: Test the Connection</h3>
<pre><code class="language-bash">ssh -T git@github.com
</code></pre>
<p>You should see: <code>Hi username! You&#39;ve successfully authenticated...</code></p>
<h3>Step 6: Use SSH URLs</h3>
<p>When cloning or adding remotes, use SSH URLs instead of HTTPS:</p>
<pre><code># SSH format:
git@github.com:owner/repo.git

# Instead of HTTPS:
https://github.com/owner/repo.git
</code></pre>
<hr>
<h2>Switching Between HTTPS and SSH</h2>
<p>If you cloned with HTTPS but want to use SSH (or vice versa), update the remote:</p>
<p><strong>Check your current remote:</strong></p>
<pre><code class="language-bash">git remote -v
</code></pre>
<p><strong>Switch to SSH:</strong></p>
<pre><code class="language-bash">git remote set-url origin git@github.com:your-username/repo.git
</code></pre>
<p><strong>Switch to HTTPS:</strong></p>
<pre><code class="language-bash">git remote set-url origin https://github.com/your-username/repo.git
</code></pre>
<hr>
<h2>Troubleshooting</h2>
<h3>&quot;Authentication failed&quot; when pushing</h3>
<p><strong>Problem:</strong> Your token expired or is incorrect.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Generate a new PAT</li>
<li>Clear your credential cache (Windows: Credential Manager; macOS: Keychain; Linux: <code>git credential-cache exit</code>)</li>
<li>Try pushing again — Git will ask for credentials</li>
</ul>
<h3>&quot;Permission denied (publickey)&quot;</h3>
<p><strong>Problem:</strong> SSH key not properly set up.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Verify your key is added to GitHub: <a href="https://github.com/settings/keys">github.com/settings/keys</a></li>
<li>Check SSH agent is running: <code>ssh-add -l</code></li>
<li>Add your key to the agent: <code>ssh-add ~/.ssh/id_ed25519</code></li>
</ul>
<h3>&quot;Host key verification failed&quot;</h3>
<p><strong>Problem:</strong> SSH doesn&#39;t recognize GitHub&#39;s host key.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash">ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts
</code></pre>
<hr>
<h2>Security Best Practices</h2>
<ol>
<li><strong>Never share your private key or PAT</strong> — treat them like passwords</li>
<li><strong>Use scoped PATs</strong> — only grant the minimum permissions needed</li>
<li><strong>Set expiration dates</strong> on PATs — regenerate periodically</li>
<li><strong>Use a passphrase</strong> on SSH keys — adds another layer of security</li>
<li><strong>Revoke old tokens</strong> when you&#39;re done with a project or device</li>
<li><strong>Don&#39;t commit tokens or keys to Git</strong> — use <code>.gitignore</code> for config files</li>
</ol>
<hr>
<h2>Commit Signing — Verified Badges and Vigilant Mode</h2>
<p>When you push commits to GitHub, each commit shows a small badge: <strong>Verified</strong> or <strong>Unverified</strong>. This badge tells anyone viewing the commit history whether the commit was cryptographically signed — proving it came from you and was not tampered with.</p>
<h3>Why It Matters</h3>
<p>Open source maintainers increasingly require signed commits before merging. Some repositories enforce this with branch protection rules. If you contribute to <code>agent-forge</code> and your commits show &quot;Unverified,&quot; a maintainer may ask you to sign them before the PR can be merged.</p>
<h3>Two Methods for Signing Commits</h3>
<h4>SSH Signing (simpler — reuses your existing SSH key)</h4>
<p>If you already have an SSH key set up for authentication, you can use it for signing too.</p>
<p><strong>Step 1: Configure Git to use SSH for signing:</strong></p>
<pre><code class="language-bash">git config --global gpg.format ssh
git config --global user.signingkey ~/.ssh/id_ed25519.pub
git config --global commit.gpgsign true
</code></pre>
<p><strong>Step 2: Add your SSH key as a signing key on GitHub:</strong></p>
<ol>
<li>Navigate to <a href="https://github.com/settings/ssh">github.com/settings/ssh</a></li>
<li>Select <strong>&quot;New SSH key&quot;</strong></li>
<li>Change <strong>&quot;Key type&quot;</strong> to <strong>&quot;Signing Key&quot;</strong> (not Authentication Key)</li>
<li>Paste your public key and save</li>
</ol>
<p>Your commits now show the <strong>Verified</strong> badge in GitHub&#39;s commit history.</p>
<h4>GPG Signing (traditional method)</h4>
<p><strong>Step 1: Generate a GPG key:</strong></p>
<pre><code class="language-bash">gpg --full-generate-key
# Choose: RSA and RSA, 4096 bits, never expires
# Enter your GitHub email address when prompted
</code></pre>
<p><strong>Step 2: Find your key ID:</strong></p>
<pre><code class="language-bash">gpg --list-secret-keys --keyid-format=long
# Output includes: sec   rsa4096/XXXXXXXXXXXXXXXX
# The X&#39;s are your key ID
</code></pre>
<p><strong>Step 3: Export the public key:</strong></p>
<pre><code class="language-bash">gpg --armor --export YOUR_KEY_ID
# Copies the block starting with -----BEGIN PGP PUBLIC KEY BLOCK-----
</code></pre>
<p><strong>Step 4: Add to GitHub:</strong></p>
<ol>
<li>Navigate to <a href="https://github.com/settings/gpg-keys">github.com/settings/gpg-keys</a></li>
<li>Select <strong>&quot;New GPG key&quot;</strong> → paste the exported public key</li>
</ol>
<p><strong>Step 5: Configure Git to sign all commits:</strong></p>
<pre><code class="language-bash">git config --global user.signingkey YOUR_KEY_ID
git config --global commit.gpgsign true
</code></pre>
<h3>Vigilant Mode</h3>
<p>GitHub has an optional setting called <strong>Vigilant Mode</strong> (in Settings → SSH and GPG Keys → Vigilant mode). When enabled, GitHub marks <strong>all</strong> commits from your account as &quot;Unverified&quot; unless they are signed — even commits that were previously shown without a badge.</p>
<p><strong>Why some maintainers enable Vigilant Mode:</strong></p>
<ul>
<li>It makes tampered or spoofed commits immediately obvious</li>
<li>It signals that the repository cares about commit provenance</li>
</ul>
<p><strong>What you see as a contributor:</strong></p>
<ul>
<li>Every unsigned commit you push will show a yellow &quot;Unverified&quot; badge</li>
<li>This is a visual signal — commits can still be pushed, but maintainers may block the merge</li>
</ul>
<p><strong>To read verification badges with a screen reader:</strong></p>
<ul>
<li>Navigate to the repository&#39;s commit history (Code tab → Commits link)</li>
<li>Each commit row contains either &quot;Verified&quot; or &quot;Unverified&quot; as a badge element</li>
<li>NVDA/JAWS: the badge is inside the commit row; use <code>↓</code> to read through each row and the badge text is read inline</li>
<li>VoiceOver: use <code>VO+Right</code> through the commit row; the badge is read as a button with the text &quot;Verified&quot; (clicking it shows the certificate)</li>
</ul>
<p><strong>Workshop recommendation:</strong> SSH signing is simpler to set up than GPG and reuses your existing key. If you have 10 minutes, configure it before Day 2 — every commit you push to agent-forge will show as Verified.</p>
<hr>
<h2>For This Workshop</h2>
<p><strong>Recommended approach:</strong></p>
<ol>
<li>Generate a Personal Access Token with 30-day expiration</li>
<li>Scope: <code>repo</code> and <code>workflow</code></li>
<li>Store it in your password manager</li>
<li>Use it when VS Code or Git asks for a password</li>
</ol>
<p>SSH keys are great for long-term use, but PATs are faster to set up and more accessible for screen reader users during a time-constrained workshop.</p>
<hr>
<p><em>Return to: <a href="00-pre-workshop-setup.md">Pre-Workshop Setup</a> | <a href="appendix-q-resources.md">Resources</a></em></p>

  </main>
  <footer role="contentinfo" style="text-align: center; margin-top: 3rem; padding: 2rem; border-top: 1px solid #d0d7de;">
    <p>GitHub Learning Room - Open Source Assistive Technology Hackathon</p>
    <p><a href="https://github.com">Back to GitHub</a></p>
  </footer>
</body>
</html>